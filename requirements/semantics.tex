\section{Semantics}
\label{sec:semantics}

The section informally describes the semantics of \textit{Sequential
  Function Charts (SFC's)}, as (to be) realized in the tool \Slime.  The
semantics is defined for successfully \emph{checked} SFC's (cf.\ 
Section~\ref{sec:checks}); unchecked SFC's don't have a meaning.
Especially, the simulator, which realizes the semantics, can assume checked
syntax.



\subsection{Sequential Function Charts}

We explain the semantics with the help of the example from
Figure~\ref{fig:SFC}.


\ifweb
\begin{figure}[htbp]
  \centering
  \begin{rawhtml}
    <BR>
    <DIV ALIGN=center>
    <IMG SRC="sfc-figure.gif">
    </DIV><BR>  
  \end{rawhtml}  
  \caption{SFC}
  \label{fig:SFC}
\end{figure}

\else
\begin{figure}[htbp]
  \centering
  \input{sfc-figure}
  \caption{SFC}
  \label{fig:SFC}
\end{figure}

%\includegraphics[height=10cm,clip=]{sfc-figure1.ps}
\fi


The SFC's consist of nodes, called \emph{steps}, to which \emph{actions} are
associated, and \emph{transitions} between steps, decorated with boolean
\emph{guards.} Always, one ore more of the steps are active and the actions
associate with this active steps are executed within one cycle.  The
transition from $s_1$ to both $s_2$ and $s_3$ (with double horizontal line) is
a \emph{parallel} branching: if this transition is taken, $s_1$ is deactivated
and both $s_2$ and $s_3$ get activated.  Since this is one transition, and
each transition has exactly one guard, the guard is labeled on the upper part
of the transition.

In contrast, the ``branching'' from $s_3$ to $s_5$ and $s_6$ is no real
branching, it is just an abbreviation for two different transitions: one
leading from $s_3$ to $s_5$, the other leading from $s_3$ to $s_6$.
Therefore, the guards are labeled to the lower parts, since each transition
has exactly one guard.

The topmost step (marked specifically) is \emph{initial.}  The ''N'' on the
left-hand side of the actions is a \emph{qualifier}, stating that the action
is to be executed in each cycle in which the step is active. There are other
qualifiers, too, but we will neglect them unless we find good reasons for
taking them into account.

The behavior of an SFC during one \emph{cycle} is as follows.
\begin{enumerate}
\item Reading inputs from the environment.
\item Executing the actions from the active steps.  This is done in two steps
  as follows:
  \begin{enumerate}
  \item Assemble all active actions (as a set, so each action appears at most
    one time).
  \item Execute the assembled actions in an arbitrary order.
  \end{enumerate}
\item Evaluate the guards.\footnote{If one does not allow propositions like
    \emph{step\_1\_is\_active}, taking a transition can only disable another
    transition by deactivating its source steps, the guards will remain true.}
\item Take transition(s) (if possible).
\item Write outputs.
\end{enumerate}
The cycle is executed repeatedly.  The parts for \emph{reading inputs} and
\emph{writing outputs} are irrelevant for us, as we consider closed systems
only, i.e., systems whose variables are changed only by the system itself, but
not by the outside.

Each transition is equipped by a \emph{guard,} i.e., a boolean expression. A
transition can be taken only if the guard evaluates to true, and, if all the
source steps of the transition are active.  We do not enforce the target steps
to be disabled.\footnote{If during a run a transition is taking which enters
  an already active step, the SFC is either built using a strange programming
  style or there is a mistake.  But in principle, there seems to be no reason
  to enforce target steps to be deactive.}

If more than one step is active in a parallel branch, the execution of the
corresponding action is chosen \emph{non-deterministically}. This means,
they can be executed in an arbitrary order (\emph{interleaving semantics}).

There is a second source of non-determinism, namely the set of actions
associated to the active steps.  These actions will be first assembled, and
then non-deterministically executed.  Each action will only be executed once,
even if an action is associated to two different active steps.

Consequently, a program may have a number of different execution runs.  The
simulator could realize the different runs in that it asks the user, in which
order the actions should be performed, and which transition should be taken if
several are possible.  An alternative is, to determine the order by a random
generator.

The transition from $s_4$ and $s_7$ to $s_8$ closes the parallel branch again.
Such a transition can be taken only, if \emph{all} source steps are active. In
other words, this transition can be taken if it's guard evaluates to true and
furthermore both $s_4$ and $s_7$ are active.



\subsection{States}
\label{sec:states}

The global state of a program is given by the assignment to all variables and
the set of all active steps.


\subsection{Formal semantics}

In this section, we define the operational semantics for SFCs as realized
in \Slime. An SFC-program is as a tuple $(S,s_i,T,\Var,\act)$, where $S$ is
the (finite) set of steps, $s_i \in S$ the initial step, and $T$ the set of
transitions, where $T \subseteq 2^S \times \Expr \times 2^S$ and $\Expr$ is
the set of expressions. We write $s, s' \ldots$ for typical elements of
$\Steps$ $t,t', t_1, \ldots$ for typical transitions. The set $\Var$ is the
set of \emph{variables} where we silently assume all variables to be well
typed.\footnote{This corresponds to the agreement, that the simulator can
  rely on \emph{checked} syntax.}  By the typing, some variables are marked
as input or output variables or both, and we write $\Varin$ and $\Varout$
for the corresponding subsets of $\Var$. Variables that are neither input
nor output variable we call \emph{local} variable from the set $\Varloc$


 The last component $\act \of S \to
2^\Act$ finally attaches a set of actions to each steps.\footnote{The
  example from above in Figure~\ref{fig:SFC} is simplified insofar, as it
  contains at most \emph{one} action per step.}


\subsubsection{Stores and states}





The global \emph{store} contains the values of all variables and is
modelled as a mapping $\Store = \Var \to D$; we use $\eta$ as typical
element. A \emph{state} $\sigma \of \Sigma = 2^\Steps \times \Store \times
\States$ of a program is characterised by a set of active steps together
with a store.

The initial state



\subsubsection{Operational semantics}


The operational rules are shown in Figure~\ref{tab:operationalsemantics}.
An execution cycle start by reading the input (cf.\ rule \rn{Input}), when
the system is currently in the waiting state. After updating the store
$\eta$ by assigning values to all input variable as read from the
environment, the system goes into stage where executing all currently
active actions given by $\act{\sigma}$, which are collected in rule
\rn{Input} into the status. In the next stage, the system executes
non-deterministically one action after the other as given in rule \rn{Act}.
In this rule $\sem{}{a}$ is the state-transforming effect of the statement
belonging to the action $a$, i.e., $\sem{}{a}(\eta)$ is the state after
executing $a$. Since actions contain only sequences of variable
assignments, we omit a formal definition of the update semantics of
actions. When no action is left, all currently enabled transitions are
collected, i.e., the transitions whose source steps are all active and
whose guards evaluate to $\ltrue$ (cf.\ rule \rn{No-Act}). The rule
\rn{Next-Steps} calucates the set of active successor steps by working off
the transitions from $\finished{T}$ one after the other. Note that this
rule and rule \rn{No-Act} do not have side effects.\footnote{The
  formulation in \rn{No-Act} collecting all enabled transitions and
  afterwards calculating the successors with \rn{Next-Steps} rests on the
  assumption that the guards are side-effect free. Especially, there are
  no expressions checking for enabledness of transitions.} When the
transitions are worked-off, output is written in the last stage of the
cycle and the system enters phase where it waits for new input again (cf.\ 
rule \rn{Output}).


\begin{table}[htbp]
  \begin{ruleset}
    \input{sos-rules}  
  \end{ruleset}
  \caption{Operational semantics}
  \label{tab:operationalsemantics}
\end{table}







%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 
